import torch
import numpy as np
from PIL import Image, ImageDraw
import xml.etree.ElementTree as ET
import random
import os
import re
from svglib.svglib import svg2rlg
from reportlab.graphics import renderPM
import io

# 官方提供的 tensor 和 pil 转换函数
# Tensor to PIL
def tensor2pil(image):
    # ComfyUI tensor 格式：(批次, 高度, 宽度, 通道)
    image = image.squeeze().cpu().numpy()  # 移除批次维度，转换为 numpy 数组
    
    if image.shape[2] == 4:  # 如果有 alpha 通道
        # 已经是 HWC 格式，直接转换为 uint8
        image = (image * 255).astype(np.uint8)
        return Image.fromarray(image, mode='RGBA')
    elif image.shape[2] == 3:  # 如果只有 RGB 通道
        image = (image * 255).astype(np.uint8)
        return Image.fromarray(image, mode='RGB')
    else:
        raise ValueError(f"Unexpected number of channels: {image.shape[2]}")

# Convert PIL to Tensor
def pil2tensor(image):
    # 确保图像是 RGBA 模式
    if image.mode != 'RGBA':
        image = image.convert('RGBA')
    
    # 转换为 numpy 数组，然后转换为 tensor
    np_image = np.array(image).astype(np.float32) / 255.0
    return torch.from_numpy(np_image).unsqueeze(0)  # 只添加批次维度

class BK_SvgLayout:

    @classmethod
    def INPUT_TYPES(s):
        return {
            "required": {
                "images": ("IMAGE",),
                "svg": ("STRING", {"multiline": True}),
            },
            "optional": {
                "num_images": ("INT", {
                    "default": 5,
                    "min": 1,
                    "max": 100,
                    "step": 1
                }),
                "max_offset": ("INT", {
                    "default": 20,
                    "min": 0,
                    "max": 100,
                    "step": 1
                }),
                "max_rotation": ("FLOAT", {
                    "default": 45.0,
                    "min": 0.0,
                    "max": 360.0,
                    "step": 0.1
                }),
                "min_scale": ("FLOAT", {
                    "default": 0.5,
                    "min": 0.1,
                    "max": 1.0,
                    "step": 0.1
                }),
                "max_scale": ("FLOAT", {
                    "default": 1.5,
                    "min": 1.0,
                    "max": 5.0,
                    "step": 0.1
                }),
                "draw_svg_path": ("BOOLEAN", {
                    "default": False,
                    "label": "Draw SVG Path"
                }),
            }
        }

    CATEGORY = "⭐️ Baikong/Image"
    RETURN_TYPES = ("IMAGE",)
    FUNCTION = "exec"
    OUTPUT_NODE = False
    DESCRIPTION = "从输入的 svg 中解析 path 路径，并将输入的的图片随机散布在 svg 路径上"

    def parse_path(self, d):
        commands = re.findall(r'([MLHVCSQTAZ])([^MLHVCSQTAZ]*)', d.upper())
        path = []
        current_point = [0, 0]
        for command, params in commands:
            params = [float(p) for p in params.replace(',', ' ').split()]
            if command == 'M':
                path.extend(list(zip(params[::2], params[1::2])))
                current_point = path[-1]
            elif command == 'L':
                path.extend(list(zip(params[::2], params[1::2])))
                current_point = path[-1]
            elif command == 'H':
                for x in params:
                    path.append((x, current_point[1]))
                    current_point = [x, current_point[1]]
            elif command == 'V':
                for y in params:
                    path.append((current_point[0], y))
                    current_point = [current_point[0], y]
            # 可以根据需要添加更多命令的处理
        return path

    def exec(
        self,
        images,
        svg,
        num_images=5,
        max_offset=20,
        max_rotation=45.0,
        min_scale=0.5,
        max_scale=1.5,
        draw_svg_path=False,
    ):

        # 清理 SVG 字符串
        svg = svg.strip()  # 移除首尾的空白字符
        if not svg.startswith('<?xml') and not svg.startswith('<svg'):
            svg = f'<svg xmlns="http://www.w3.org/2000/svg">{svg}</svg>'

        try:
            # 尝试解析 SVG
            root = ET.fromstring(svg)
        except ET.ParseError as e:
            print(f"Error parsing SVG: {e}")
            # 如果解析失败，创建一个空的 SVG
            svg = '<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400"></svg>'
            root = ET.fromstring(svg)

        # 从 svg 图像获取图像尺寸
        width = int(root.get('width', '400'))
        height = int(root.get('height', '400'))

        # 将 SVG 转换为 PIL Image
        try:
            drawing = svg2rlg(io.StringIO(svg))
            svg_image = Image.open(io.BytesIO(renderPM.drawToString(drawing, fmt="PNG")))
            svg_image = svg_image.convert('RGBA')
        except Exception as e:
            print(f"Error rendering SVG: {e}")
            svg_image = Image.new('RGBA', (width, height), (255, 255, 255, 0))

        # 创建一个新的画布，并将 SVG 图像放在底部
        canvas = Image.new('RGBA', (width, height), (255, 255, 255, 0))
        canvas.alpha_composite(svg_image, (0, 0))

        # 解析路径数据
        paths = root.findall(".//{http://www.w3.org/2000/svg}path")
        path_data = [path.get('d') for path in paths]

        # 随机选择图像并放置在路径上，总共 num_images 次
        for _ in range(num_images):
            # 随机选择一张输入图像
            img = random.choice(images)
            
            # 随机选择一个路径
            if path_data:
                path = self.parse_path(random.choice(path_data))
                
                # 随机选择路径上的一个点
                if path:
                    point = random.choice(path)
                else:
                    point = (random.randint(0, width), random.randint(0, height))
            else:
                point = (random.randint(0, width), random.randint(0, height))
            
            # 应用随机变换
            x, y = point
            x += random.uniform(-max_offset, max_offset)
            y += random.uniform(-max_offset, max_offset)
            rotation = random.uniform(-max_rotation, max_rotation)
            scale = random.uniform(min_scale, max_scale)
            
            # 将 tensor 转换为 PIL 图像
            pil_img = tensor2pil(img)
            
            # 确保图像是 RGBA 模式
            if pil_img.mode != 'RGBA':
                pil_img = pil_img.convert('RGBA')
            
            # 应用变换
            pil_img = pil_img.rotate(rotation, expand=True, resample=Image.BICUBIC)
            new_size = (int(pil_img.width * scale), int(pil_img.height * scale))
            pil_img = pil_img.resize(new_size, Image.LANCZOS)
            
            # 将图像粘贴到画布上
            paste_x = int(x - pil_img.width // 2)
            paste_y = int(y - pil_img.height // 2)
            
            # 使用 alpha 合成
            canvas.alpha_composite(pil_img, (paste_x, paste_y))

        # 将图像转换回 tensor 格式并输出
        result = pil2tensor(canvas)
        print("Output tensor shape:", result.shape)  # 添加这行来检查输出形状
        return (result,)

if __name__ == "__main__":
    selector_node = BK_SvgLayout()
    
    # 读取测试图片
    test_images = []
    for i in range(1, 4):
        img_path = f"test{i}.png"
        if os.path.exists(img_path):
            pil_img = Image.open(img_path).convert("RGB")  # 转换为 RGB
            img_tensor = pil2tensor(pil_img)
            test_images.append(img_tensor)
        else:
            print(f"警告：找不到图片 {img_path}")

    if not test_images:
        print("错误：没有找到任何测试图片")
    else:
        test_svg = '''
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="none" version="1.1" width="400" height="400" viewBox="0 0 400 400"><defs><clipPath id="master_svg0_28_0207"><rect x="0" y="0" width="400" height="400" rx="0"/></clipPath></defs><g clip-path="url(#master_svg0_28_0207)"><rect x="0" y="0" width="400" height="400" rx="0" fill="#FFFFFF" fill-opacity="1"/><g><path d="M149.31900000000002,287.826Q149.309,287.825,149.3,287.824Q148.86700000000002,287.786,148.433,287.786Q148.188,287.786,147.94299999999998,287.798Q147.697,287.81,147.453,287.834Q147.209,287.858,146.966,287.895Q146.72320000000002,287.93100000000004,146.48239999999998,287.978Q146.24169999999998,288.026,146.0035,288.086Q145.7654,288.14599999999996,145.53050000000002,288.217Q145.29559999999998,288.288,145.0644,288.371Q144.8333,288.454,144.60649999999998,288.547Q144.3797,288.64099999999996,144.1578,288.746Q143.9359,288.851,143.7194,288.967Q143.5029,289.08299999999997,143.2923,289.209Q143.0817,289.33500000000004,142.8776,289.472Q142.6735,289.608,142.47629999999998,289.754Q142.2792,289.9,142.0894,290.05600000000004Q141.8997,290.212,141.7178,290.377Q141.5359,290.54200000000003,141.3623,290.71500000000003Q141.18869999999998,290.889,141.0238,291.071Q140.85899999999998,291.253,140.70319999999998,291.442Q140.5475,291.632,140.4013,291.829Q140.255,292.026,140.11860000000001,292.231Q139.9823,292.435,139.8561,292.645Q139.7298,292.856,139.6141,293.072Q139.4984,293.289,139.39339999999999,293.51099999999997Q139.2885,293.733,139.1945,293.959Q139.1006,294.18600000000004,139.0179,294.41700000000003Q138.9352,294.648,138.8639,294.88300000000004Q138.7927,295.118,138.733,295.356Q138.67340000000002,295.595,138.6255,295.83500000000004Q138.57760000000002,296.076,138.54160000000002,296.31899999999996Q138.50560000000002,296.562,138.48149999999998,296.80600000000004Q138.4574,297.05,138.4454,297.296Q138.4333,297.541,138.4333,297.786Q138.4333,298.01800000000003,138.4441,298.25Q138.4548,298.48199999999997,138.47629999999998,298.712Q138.49779999999998,298.943,138.53,299.173Q138.5621,299.403,138.6049,299.631Q138.6477,299.85900000000004,138.701,300.084Q138.7543,300.31,138.81799999999998,300.533Q138.8817,300.756,138.95569999999998,300.976Q139.0297,301.196,139.1137,301.41200000000003Q139.1978,301.628,139.2918,301.84000000000003Q139.3859,302.052,139.4896,302.26Q139.5933,302.467,139.70659999999998,302.669Q139.8198,302.872,139.94240000000002,303.06899999999996Q140.0649,303.26599999999996,140.19639999999998,303.457Q140.3279,303.648,140.4681,303.832Q140.60829999999999,304.017,140.757,304.195Q140.9056,304.373,141.0623,304.544Q141.2191,304.71500000000003,141.3836,304.879Q141.5481,305.04200000000003,141.72,305.198Q141.8918,305.353,142.07080000000002,305.501Q142.24970000000002,305.649,142.43529999999998,305.788Q142.6208,305.927,142.8127,306.057Q143.0045,306.188,143.2022,306.30899999999997Q143.3998,306.43,143.6029,306.54200000000003Q143.80599999999998,306.654,144.014,306.757Q144.2221,306.85900000000004,144.4346,306.952Q144.6472,307.04499999999996,144.8639,307.128Q145.0805,307.21000000000004,145.30079999999998,307.283Q145.52100000000002,307.356,145.74439999999998,307.418Q145.9678,307.48,146.1938,307.53200000000004Q146.4198,307.584,146.648,307.626Q146.87619999999998,307.66700000000003,147.106,307.698Q147.336,307.72900000000004,147.567,307.749Q147.57,307.749,147.574,307.749Q147.578,307.75,147.583,307.75Q151.387,308.079,158.348,307.749Q165.15,307.426,168.613,308.01800000000003Q175.9,312.881,182.605,312.262Q190.879,311.497,195.808,303.49199999999996Q199.698,297.174,202.944,278.884Q203.73,274.457,204.146,272.339Q217.588,202.56799999999998,204.203,120.6044L204.081,119.8627L203.851,119.14750000000001Q203.428,117.8359,202.537,114.9765Q197.255,98.033944,193.295,93.54406Q189.439,89.17367,184.182,89.00607Q178.06,88.8109,173.978,94.10389Q170.885,98.116248,168.66,107.36555Q164.102,113.2663,157.34,124.5901Q150.511,136.0255,146.9235,140.3654Q142.0746,146.2311,137.6311,147.5619L134.949,148.36509999999998L133.07389999999998,150.4443Q128.8413,155.1375,124.0745,154.95170000000002Q120.1904,154.8002,110.525,150.8318Q99.23140000000001,146.1949,92.9405,145.5245Q80.73349999999999,144.2236,71.3868,152.1283Q48.3503,169.1183,41.1524,213.672Q37.1838,238.237,37.03252,290.004Q37.01551,295.823,37.00026,298.656Q37.000209999999996,298.66499999999996,37.00016,298.675Q37,298.703,37,298.73Q37,298.976,37.01205,299.221Q37.02409,299.466,37.04815,299.71000000000004Q37.07222,299.95500000000004,37.10824,300.197Q37.14426,300.44,37.19215,300.68100000000004Q37.24004,300.922,37.29969,301.15999999999997Q37.35934,301.398,37.4306,301.63300000000004Q37.50186,301.868,37.584559999999996,302.099Q37.66726,302.33000000000004,37.76121,302.557Q37.85515,302.784,37.96011,303.006Q38.06507,303.228,38.18079,303.44399999999996Q38.29651,303.661,38.42271,303.871Q38.54892,304.082,38.68531,304.286Q38.821690000000004,304.49,38.96793,304.687Q39.11416,304.884,39.2699,305.074Q39.42563,305.264,39.59049,305.446Q39.75535,305.628,39.92893,305.801Q40.10252,305.975,40.28441,306.14Q40.466300000000004,306.305,40.65607,306.46000000000004Q40.84583,306.616,41.04301,306.762Q41.24018,306.908,41.4443,307.04499999999996Q41.64841,307.18100000000004,41.85897,307.307Q42.06953,307.43399999999997,42.28603,307.549Q42.50253,307.66499999999996,42.72445,307.77Q42.94637,307.875,43.17317,307.969Q43.39997,308.063,43.6311,308.14599999999996Q43.86224,308.228,44.09715,308.3Q44.33207,308.371,44.5702,308.43Q44.80833,308.49,45.0491,308.538Q45.28987,308.586,45.5327,308.622Q45.77552,308.658,46.019829,308.682Q46.264133,308.706,46.509323,308.71799999999996Q46.754514,308.73,47,308.73Q47.244642,308.73,47.488991,308.71799999999996Q47.73334,308.706,47.976812,308.682Q48.22028,308.658,48.4623,308.623Q48.70431,308.587,48.94428,308.539Q49.18425,308.49199999999996,49.42161,308.433Q49.65897,308.373,49.89315,308.303Q50.12733,308.23199999999997,50.35777,308.15Q50.588210000000004,308.067,50.81435,307.974Q51.0405,307.881,51.26181,307.777Q51.48312,307.672,51.69907,307.557Q51.91502,307.442,52.12509,307.317Q52.33516,307.192,52.53885,307.05600000000004Q52.74254,306.921,52.93935,306.775Q53.13617,306.63,53.32565,306.475Q53.515119999999996,306.321,53.69681,306.15700000000004Q53.87849,305.993,54.05194,305.82Q54.2254,305.648,54.390209999999996,305.467Q54.55502,305.286,54.71079,305.098Q54.86657,304.909,55.01293,304.71299999999997Q55.15929,304.517,55.29589,304.31399999999996Q55.43249,304.111,55.55901,303.902Q55.68552,303.692,55.80165,303.477Q55.917770000000004,303.262,56.02323,303.041Q56.12868,302.82,56.22322,302.594Q56.317750000000004,302.369,56.40114,302.139Q56.48453,301.909,56.55657,301.675Q56.62861,301.44100000000003,56.68914,301.204Q56.74966,300.967,56.798519999999996,300.727Q56.84738,300.488,56.884460000000004,300.246Q56.92154,300.004,56.94676,299.76099999999997Q56.97197,299.517,56.98525,299.273Q56.99853,299.029,56.99985,298.784Q57.015299999999996,295.927,57.0324,290.062Q57.1791,239.871,60.8964,216.862Q66.8304,180.1311,83.4692,168.06959999999998L83.8262,167.8109L84.15899999999999,167.5216Q87.0497,165.00990000000002,90.8212,165.4119Q94.2747,165.7799,102.92869999999999,169.3331Q115.8712,174.64690000000002,123.2952,174.9365Q136.19389999999999,175.4395,146.0738,165.77030000000002Q154.785,162.2456,162.338,153.1082Q166.899,147.591,174.511,134.8441Q179.929,125.7707,183.452,120.95949999999999Q184.154,123.2094,184.582,124.5558Q197.217,202.586,184.521,268.486Q184.07,270.78200000000004,183.252,275.389Q181.194,286.985,179.572,291.28999999999996Q179.215,291.043,178.82,290.746L177.362,289.64599999999996L175.61,289.13300000000004Q169.06799999999998,287.217,157.4,287.77099999999996Q151.789,288.03700000000003,149.31900000000002,287.826Z" fill-rule="evenodd" fill="#D8D8D8" fill-opacity="1"/></g></g></svg>
        '''
        result = selector_node.exec(test_images, test_svg)
        print("测试完成，输出图像形状：", result[0].shape)
        
        # 保存结果图像
        output_img = tensor2pil(result[0])
        output_img.save("output_test.png")
        print("结果图像已保存为 output_test.png")
